import {
  require_string_trim,
  require_whitespaces
} from "./chunk-NUN7EF6O.js";
import {
  require_is_regexp
} from "./chunk-374K4F2Q.js";
import {
  require_species_constructor
} from "./chunk-W5VTHPFA.js";
import {
  require_array_method_is_strict,
  require_regexp_get_flags
} from "./chunk-DULN5XOP.js";
import {
  require_advance_string_index,
  require_array_slice_simple,
  require_correct_prototype_getter,
  require_fix_regexp_well_known_symbol_logic,
  require_inherit_if_required,
  require_object_get_prototype_of,
  require_regexp_exec,
  require_regexp_exec_abstract,
  require_regexp_sticky_helpers,
  require_regexp_unsupported_dot_all,
  require_regexp_unsupported_ncg,
  require_to_string
} from "./chunk-6O5VAYEU.js";
import {
  require_an_object,
  require_create_non_enumerable_property,
  require_define_built_in,
  require_descriptors,
  require_export,
  require_fails,
  require_function_apply,
  require_function_call,
  require_function_name,
  require_function_uncurry_this,
  require_get_method,
  require_global,
  require_has_own_property,
  require_indexed_object,
  require_internal_state,
  require_is_forced,
  require_is_null_or_undefined,
  require_object_define_property,
  require_object_get_own_property_names,
  require_object_is_prototype_of,
  require_require_object_coercible,
  require_set_species,
  require_to_indexed_object,
  require_to_length,
  require_to_object,
  require_well_known_symbol
} from "./chunk-KXVYMO3Q.js";
import {
  __commonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/core-js/internals/proxy-accessor.js
var require_proxy_accessor = __commonJS({
  "node_modules/core-js/internals/proxy-accessor.js"(exports, module) {
    var defineProperty = require_object_define_property().f;
    module.exports = function(Target, Source, key) {
      key in Target || defineProperty(Target, key, {
        configurable: true,
        get: function() {
          return Source[key];
        },
        set: function(it) {
          Source[key] = it;
        }
      });
    };
  }
});

// node_modules/core-js/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS({
  "node_modules/core-js/internals/string-trim-forced.js"(exports, module) {
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var fails4 = require_fails();
    var whitespaces = require_whitespaces();
    var non = "\u200B\x85\u180E";
    module.exports = function(METHOD_NAME) {
      return fails4(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
  }
});

// node_modules/core-js/modules/es.array.join.js
var $ = require_export();
var uncurryThis = require_function_uncurry_this();
var IndexedObject = require_indexed_object();
var toIndexedObject = require_to_indexed_object();
var arrayMethodIsStrict = require_array_method_is_strict();
var nativeJoin = uncurryThis([].join);
var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict("join", ",");
$({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
  join: function join(separator) {
    return nativeJoin(toIndexedObject(this), separator === void 0 ? "," : separator);
  }
});

// node_modules/core-js/modules/es.object.get-prototype-of.js
var $2 = require_export();
var fails = require_fails();
var toObject = require_to_object();
var nativeGetPrototypeOf = require_object_get_prototype_of();
var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
var FAILS_ON_PRIMITIVES = fails(function() {
  nativeGetPrototypeOf(1);
});
$2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});

// node_modules/core-js/modules/es.string.match.js
var call = require_function_call();
var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
var anObject = require_an_object();
var isNullOrUndefined = require_is_null_or_undefined();
var toLength = require_to_length();
var toString = require_to_string();
var requireObjectCoercible = require_require_object_coercible();
var getMethod = require_get_method();
var advanceStringIndex = require_advance_string_index();
var regExpExec = require_regexp_exec_abstract();
fixRegExpWellKnownSymbolLogic("match", function(MATCH2, nativeMatch, maybeCallNative) {
  return [
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = isNullOrUndefined(regexp) ? void 0 : getMethod(regexp, MATCH2);
      return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH2](toString(O));
    },
    function(string) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(nativeMatch, rx, S);
      if (res.done)
        return res.value;
      if (!rx.global)
        return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = toString(result[0]);
        A[n] = matchStr;
        if (matchStr === "")
          rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

// node_modules/core-js/modules/es.regexp.constructor.js
var DESCRIPTORS = require_descriptors();
var global = require_global();
var uncurryThis2 = require_function_uncurry_this();
var isForced = require_is_forced();
var inheritIfRequired = require_inherit_if_required();
var createNonEnumerableProperty = require_create_non_enumerable_property();
var getOwnPropertyNames = require_object_get_own_property_names().f;
var isPrototypeOf = require_object_is_prototype_of();
var isRegExp = require_is_regexp();
var toString2 = require_to_string();
var getRegExpFlags = require_regexp_get_flags();
var stickyHelpers = require_regexp_sticky_helpers();
var proxyAccessor = require_proxy_accessor();
var defineBuiltIn = require_define_built_in();
var fails2 = require_fails();
var hasOwn = require_has_own_property();
var enforceInternalState = require_internal_state().enforce;
var setSpecies = require_set_species();
var wellKnownSymbol = require_well_known_symbol();
var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
var MATCH = wellKnownSymbol("match");
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var SyntaxError = global.SyntaxError;
var exec = uncurryThis2(RegExpPrototype.exec);
var charAt = uncurryThis2("".charAt);
var replace = uncurryThis2("".replace);
var stringIndexOf = uncurryThis2("".indexOf);
var stringSlice = uncurryThis2("".slice);
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;
var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails2(function() {
  re2[MATCH] = false;
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, "i") != "/a/i";
}));
var handleDotAll = function(string) {
  var length = string.length;
  var index = 0;
  var result = "";
  var brackets = false;
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === "\\") {
      result += chr + charAt(string, ++index);
      continue;
    }
    if (!brackets && chr === ".") {
      result += "[\\s\\S]";
    } else {
      if (chr === "[") {
        brackets = true;
      } else if (chr === "]") {
        brackets = false;
      }
      result += chr;
    }
  }
  return result;
};
var handleNCG = function(string) {
  var length = string.length;
  var index = 0;
  var result = "";
  var named = [];
  var names = {};
  var brackets = false;
  var ncg = false;
  var groupid = 0;
  var groupname = "";
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === "\\") {
      chr = chr + charAt(string, ++index);
    } else if (chr === "]") {
      brackets = false;
    } else if (!brackets)
      switch (true) {
        case chr === "[":
          brackets = true;
          break;
        case chr === "(":
          if (exec(IS_NCG, stringSlice(string, index + 1))) {
            index += 2;
            ncg = true;
          }
          result += chr;
          groupid++;
          continue;
        case (chr === ">" && ncg):
          if (groupname === "" || hasOwn(names, groupname)) {
            throw new SyntaxError("Invalid capture group name");
          }
          names[groupname] = true;
          named[named.length] = [groupname, groupid];
          ncg = false;
          groupname = "";
          continue;
      }
    if (ncg)
      groupname += chr;
    else
      result += chr;
  }
  return [result, named];
};
if (isForced("RegExp", BASE_FORCED)) {
  RegExpWrapper = function RegExp2(pattern, flags) {
    var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === void 0;
    var groups = [];
    var rawPattern = pattern;
    var rawFlags, dotAll, sticky, handled, result, state;
    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
      return pattern;
    }
    if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
      pattern = pattern.source;
      if (flagsAreUndefined)
        flags = getRegExpFlags(rawPattern);
    }
    pattern = pattern === void 0 ? "" : toString2(pattern);
    flags = flags === void 0 ? "" : toString2(flags);
    rawPattern = pattern;
    if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
      dotAll = !!flags && stringIndexOf(flags, "s") > -1;
      if (dotAll)
        flags = replace(flags, /s/g, "");
    }
    rawFlags = flags;
    if (MISSED_STICKY && "sticky" in re1) {
      sticky = !!flags && stringIndexOf(flags, "y") > -1;
      if (sticky && UNSUPPORTED_Y)
        flags = replace(flags, /y/g, "");
    }
    if (UNSUPPORTED_NCG) {
      handled = handleNCG(pattern);
      pattern = handled[0];
      groups = handled[1];
    }
    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
    if (dotAll || sticky || groups.length) {
      state = enforceInternalState(result);
      if (dotAll) {
        state.dotAll = true;
        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
      }
      if (sticky)
        state.sticky = true;
      if (groups.length)
        state.groups = groups;
    }
    if (pattern !== rawPattern)
      try {
        createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
      } catch (error) {
      }
    return result;
  };
  for (keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index; ) {
    proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
  }
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  defineBuiltIn(global, "RegExp", RegExpWrapper, { constructor: true });
}
var RegExpWrapper;
var keys;
var index;
setSpecies("RegExp");

// node_modules/core-js/modules/es.string.trim.js
var $3 = require_export();
var $trim = require_string_trim().trim;
var forcedStringTrimMethod = require_string_trim_forced();
$3({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
  trim: function trim() {
    return $trim(this);
  }
});

// node_modules/core-js/modules/es.string.split.js
var apply = require_function_apply();
var call2 = require_function_call();
var uncurryThis3 = require_function_uncurry_this();
var fixRegExpWellKnownSymbolLogic2 = require_fix_regexp_well_known_symbol_logic();
var anObject2 = require_an_object();
var isNullOrUndefined2 = require_is_null_or_undefined();
var isRegExp2 = require_is_regexp();
var requireObjectCoercible2 = require_require_object_coercible();
var speciesConstructor = require_species_constructor();
var advanceStringIndex2 = require_advance_string_index();
var toLength2 = require_to_length();
var toString3 = require_to_string();
var getMethod2 = require_get_method();
var arraySlice = require_array_slice_simple();
var callRegExpExec = require_regexp_exec_abstract();
var regexpExec = require_regexp_exec();
var stickyHelpers2 = require_regexp_sticky_helpers();
var fails3 = require_fails();
var UNSUPPORTED_Y2 = stickyHelpers2.UNSUPPORTED_Y;
var MAX_UINT32 = 4294967295;
var min = Math.min;
var $push = [].push;
var exec2 = uncurryThis3(/./.exec);
var push = uncurryThis3($push);
var stringSlice2 = uncurryThis3("".slice);
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails3(function() {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function() {
    return originalExec.apply(this, arguments);
  };
  var result = "ab".split(re);
  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
});
fixRegExpWellKnownSymbolLogic2("split", function(SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
    internalSplit = function(separator, limit) {
      var string = toString3(requireObjectCoercible2(this));
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (separator === void 0)
        return [string];
      if (!isRegExp2(separator)) {
        return call2(nativeSplit, string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
      var lastLastIndex = 0;
      var separatorCopy = new RegExp(separator.source, flags + "g");
      var match, lastIndex, lastLength;
      while (match = call2(regexpExec, separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          push(output, stringSlice2(string, lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length)
            apply($push, output, arraySlice(match, 1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim)
            break;
        }
        if (separatorCopy.lastIndex === match.index)
          separatorCopy.lastIndex++;
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !exec2(separatorCopy, ""))
          push(output, "");
      } else
        push(output, stringSlice2(string, lastLastIndex));
      return output.length > lim ? arraySlice(output, 0, lim) : output;
    };
  } else if ("0".split(void 0, 0).length) {
    internalSplit = function(separator, limit) {
      return separator === void 0 && limit === 0 ? [] : call2(nativeSplit, this, separator, limit);
    };
  } else
    internalSplit = nativeSplit;
  return [
    function split(separator, limit) {
      var O = requireObjectCoercible2(this);
      var splitter = isNullOrUndefined2(separator) ? void 0 : getMethod2(separator, SPLIT);
      return splitter ? call2(splitter, separator, O, limit) : call2(internalSplit, toString3(O), separator, limit);
    },
    function(string, limit) {
      var rx = anObject2(this);
      var S = toString3(string);
      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
      if (res.done)
        return res.value;
      var C = speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y2 ? "g" : "y");
      var splitter = new C(UNSUPPORTED_Y2 ? "^(?:" + rx.source + ")" : rx, flags);
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (S.length === 0)
        return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y2 ? 0 : q;
        var z = callRegExpExec(splitter, UNSUPPORTED_Y2 ? stringSlice2(S, q) : S);
        var e;
        if (z === null || (e = min(toLength2(splitter.lastIndex + (UNSUPPORTED_Y2 ? q : 0)), S.length)) === p) {
          q = advanceStringIndex2(S, q, unicodeMatching);
        } else {
          push(A, stringSlice2(S, p, q));
          if (A.length === lim)
            return A;
          for (var i = 1; i <= z.length - 1; i++) {
            push(A, z[i]);
            if (A.length === lim)
              return A;
          }
          q = p = e;
        }
      }
      push(A, stringSlice2(S, p));
      return A;
    }
  ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y2);

export {
  require_string_trim_forced
};
//# sourceMappingURL=chunk-RJYO5UTX.js.map
